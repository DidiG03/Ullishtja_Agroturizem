{"version":3,"file":"static/js/651.6485f4b5.chunk.js","mappings":"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","sources":["services/intelligentVideoPreloader.js","components/OptimizedVideo.js"],"sourcesContent":["class IntelligentVideoPreloader {\n  constructor() {\n    this.preloadedVideos = new Map();\n    this.preloadQueue = [];\n    this.isPreloading = false;\n    this.networkInfo = this.getNetworkInfo();\n    this.deviceInfo = this.getDeviceInfo();\n    this.userBehavior = this.getUserBehavior();\n    \n    // Monitor network changes\n    this.setupNetworkMonitoring();\n    \n    // Preload critical videos on initialization\n    this.preloadCriticalVideos();\n  }\n\n  getNetworkInfo() {\n    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n    \n    if (!connection) {\n      return {\n        effectiveType: '4g',\n        downlink: 10,\n        rtt: 100,\n        saveData: false\n      };\n    }\n\n    return {\n      effectiveType: connection.effectiveType || '4g',\n      downlink: connection.downlink || 10,\n      rtt: connection.rtt || 100,\n      saveData: connection.saveData || false\n    };\n  }\n\n  getDeviceInfo() {\n    const width = window.innerWidth;\n    const memory = navigator.deviceMemory || 4;\n    const hardwareConcurrency = navigator.hardwareConcurrency || 4;\n    \n    return {\n      isMobile: width <= 768,\n      isTablet: width > 768 && width <= 1024,\n      isDesktop: width > 1024,\n      memory,\n      hardwareConcurrency,\n      isLowPower: hardwareConcurrency <= 2 || memory <= 2,\n      pixelRatio: window.devicePixelRatio || 1\n    };\n  }\n\n  getUserBehavior() {\n    // Get user behavior patterns from localStorage or set defaults\n    const stored = localStorage.getItem('video_user_behavior');\n    const defaults = {\n      averageViewTime: 30000, // 30 seconds\n      scrollSpeed: 'medium',\n      interactionPatterns: [],\n      preferredQuality: 'auto',\n      batteryOptimization: false\n    };\n\n    return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;\n  }\n\n  setupNetworkMonitoring() {\n    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n    \n    if (connection) {\n      connection.addEventListener('change', () => {\n        this.networkInfo = this.getNetworkInfo();\n        this.adjustPreloadingStrategy();\n      });\n    }\n\n    // Monitor battery status\n    if ('getBattery' in navigator) {\n      navigator.getBattery().then(battery => {\n        const updateBatteryInfo = () => {\n          this.userBehavior.batteryOptimization = battery.level < 0.2 || !battery.charging;\n        };\n        \n        battery.addEventListener('levelchange', updateBatteryInfo);\n        battery.addEventListener('chargingchange', updateBatteryInfo);\n        updateBatteryInfo();\n      });\n    }\n  }\n\n  adjustPreloadingStrategy() {\n    const { effectiveType, saveData, downlink } = this.networkInfo;\n    const { isLowPower } = this.deviceInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Clear preload queue if conditions are poor\n    if (saveData || batteryOptimization || effectiveType === 'slow-2g' || effectiveType === '2g') {\n      this.preloadQueue = [];\n      return;\n    }\n\n    // Adjust preloading aggressiveness based on network quality\n    if (effectiveType === '3g' || downlink < 5 || isLowPower) {\n      // Conservative preloading\n      this.preloadQueue = this.preloadQueue.slice(0, 2);\n    }\n  }\n\n  getOptimalVideoSource(videoId, priority = 'normal') {\n    const { isTablet, isDesktop, isLowPower } = this.deviceInfo;\n    const { effectiveType, downlink, saveData } = this.networkInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Determine optimal quality\n    let quality = 'mobile';\n    if (isTablet && !isLowPower && !saveData) quality = 'tablet';\n    if (isDesktop && !batteryOptimization && downlink > 5) quality = 'desktop';\n\n    // Downgrade for poor network conditions\n    if (effectiveType === 'slow-2g' || effectiveType === '2g') {\n      quality = 'mobile';\n    } else if (effectiveType === '3g' && quality === 'desktop') {\n      quality = 'tablet';\n    }\n\n    // Determine optimal format\n    const video = document.createElement('video');\n    const supportsWebM = video.canPlayType('video/webm') !== '';\n    const supportsAV1 = video.canPlayType('video/webm; codecs=\"av01.0.05M.08\"') !== '';\n\n    let format = 'mp4';\n    if (supportsWebM && downlink > 2) format = 'webm';\n    if (supportsAV1 && downlink > 5 && !isLowPower && priority === 'high') format = 'av1';\n\n    return {\n      src: `/videos/${videoId}-${quality}.${format === 'av1' ? 'av1.mp4' : format}`,\n      quality,\n      format,\n      poster: `/videos/${videoId}-poster.jpg`\n    };\n  }\n\n  async preloadVideo(videoId, priority = 'normal') {\n    // Check if already preloaded\n    if (this.preloadedVideos.has(videoId)) {\n      return this.preloadedVideos.get(videoId);\n    }\n\n    // Check if we should preload based on current conditions\n    if (!this.shouldPreload(priority)) {\n      return null;\n    }\n\n    const videoSource = this.getOptimalVideoSource(videoId, priority);\n    \n    try {\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n      video.muted = true;\n      video.playsInline = true;\n\n      // Create a promise that resolves when video is ready\n      const preloadPromise = new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(() => {\n          reject(new Error('Preload timeout'));\n        }, 10000); // 10 second timeout\n\n        video.addEventListener('loadedmetadata', () => {\n          clearTimeout(timeoutId);\n          resolve({\n            video,\n            source: videoSource,\n            preloadedAt: Date.now()\n          });\n        }, { once: true });\n\n        video.addEventListener('error', (event) => {\n          clearTimeout(timeoutId);\n          const errorMsg = event.target.error \n            ? `Video preload failed: ${event.target.error.message}` \n            : `Video preload failed for ${videoSource.src}`;\n          reject(new Error(errorMsg));\n        }, { once: true });\n      });\n\n      video.src = videoSource.src;\n      \n      const result = await preloadPromise;\n      this.preloadedVideos.set(videoId, result);\n      \n      // Clean up old preloaded videos if memory is getting full\n      this.cleanupOldPreloads();\n      \n      return result;\n    } catch (error) {\n      console.warn(`Failed to preload video ${videoId}:`, error.message);\n      // Don't throw error, just return null to prevent blocking other preloads\n      return null;\n    }\n  }\n\n  shouldPreload(priority) {\n    const { effectiveType, saveData, downlink } = this.networkInfo;\n    const { isLowPower } = this.deviceInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Never preload on data saver mode or very poor connections\n    if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g') {\n      return false;\n    }\n\n    // Don't preload on low battery\n    if (batteryOptimization) {\n      return priority === 'high';\n    }\n\n    // Conservative preloading on low-power devices\n    if (isLowPower) {\n      return priority === 'high' && downlink > 2;\n    }\n\n    // Liberal preloading on good connections\n    if (effectiveType === '4g' && downlink > 5) {\n      return true;\n    }\n\n    // Medium preloading on decent connections\n    if (effectiveType === '3g' || downlink > 2) {\n      return priority !== 'low';\n    }\n\n    return false;\n  }\n\n  cleanupOldPreloads() {\n    const maxPreloads = this.deviceInfo.isLowPower ? 3 : 6;\n    const now = Date.now();\n    const maxAge = 5 * 60 * 1000; // 5 minutes\n\n    // Convert to array for sorting\n    const preloads = Array.from(this.preloadedVideos.entries());\n    \n    // Remove old preloads\n    preloads.forEach(([videoId, data]) => {\n      if (now - data.preloadedAt > maxAge) {\n        this.preloadedVideos.delete(videoId);\n        if (data.video) {\n          data.video.src = '';\n          data.video.load();\n        }\n      }\n    });\n\n    // If still too many, remove oldest\n    if (this.preloadedVideos.size > maxPreloads) {\n      const sortedPreloads = preloads\n        .sort((a, b) => a[1].preloadedAt - b[1].preloadedAt)\n        .slice(0, this.preloadedVideos.size - maxPreloads);\n\n      sortedPreloads.forEach(([videoId, data]) => {\n        this.preloadedVideos.delete(videoId);\n        if (data.video) {\n          data.video.src = '';\n          data.video.load();\n        }\n      });\n    }\n  }\n\n  async preloadCriticalVideos() {\n    // Define critical videos that should be preloaded immediately\n    const criticalVideos = [\n      'dji-20240806130059-0020-d', // Hero video\n      'dji-20240806130609-0022-d'  // Most viewed video\n    ];\n\n    // Only preload if conditions are good\n    if (!this.shouldPreload('normal')) {\n      return;\n    }\n\n    // Preload critical videos with high priority\n    const preloadPromises = criticalVideos.map(async (videoId) => {\n      try {\n        return await this.preloadVideo(videoId, 'high');\n      } catch (error) {\n        console.warn(`Failed to preload critical video ${videoId}:`, error.message);\n        return null;\n      }\n    });\n\n    try {\n      await Promise.allSettled(preloadPromises);\n    } catch (error) {\n      console.warn('Some critical videos failed to preload:', error);\n    }\n  }\n\n  // Method to intelligently preload based on scroll position and user behavior\n  async preloadOnScroll(visibleVideoIds, upcomingVideoIds) {\n    if (!this.shouldPreload('normal')) {\n      return;\n    }\n\n    // Preload upcoming videos based on scroll direction and speed\n    const promises = upcomingVideoIds.slice(0, 2).map(videoId => \n      this.preloadVideo(videoId, 'normal')\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  // Get preloaded video if available\n  getPreloadedVideo(videoId) {\n    return this.preloadedVideos.get(videoId);\n  }\n\n  // Track user interaction patterns for better prediction\n  trackUserInteraction(eventType, videoId, data = {}) {\n    const interaction = {\n      timestamp: Date.now(),\n      eventType,\n      videoId,\n      ...data\n    };\n\n    this.userBehavior.interactionPatterns.push(interaction);\n\n    // Keep only recent interactions (last 100)\n    if (this.userBehavior.interactionPatterns.length > 100) {\n      this.userBehavior.interactionPatterns = this.userBehavior.interactionPatterns.slice(-100);\n    }\n\n    // Save to localStorage\n    localStorage.setItem('video_user_behavior', JSON.stringify(this.userBehavior));\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics() {\n    return {\n      preloadedCount: this.preloadedVideos.size,\n      networkType: this.networkInfo.effectiveType,\n      deviceType: this.deviceInfo.isMobile ? 'mobile' : this.deviceInfo.isTablet ? 'tablet' : 'desktop',\n      batteryOptimization: this.userBehavior.batteryOptimization,\n      memoryUsage: this.preloadedVideos.size * 0.5 // Estimated MB per preloaded video\n    };\n  }\n}\n\n// Create singleton instance\nconst intelligentVideoPreloader = new IntelligentVideoPreloader();\n\nexport default intelligentVideoPreloader; ","import React, { useState, useRef, useEffect } from 'react';\nimport intelligentVideoPreloader from '../services/intelligentVideoPreloader';\nimport './OptimizedVideo.css';\n\nconst OptimizedVideo = ({ \n  src, \n  videoId, // New prop for intelligent loading\n  poster, \n  fallbackImage, \n  alt = \"Video\", \n  className = \"\", \n  style = {},\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  playsInline = true,\n  lazy = true,\n  priority = 'normal' // New prop for preloading priority\n}) => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isVisible, setIsVisible] = useState(!lazy);\n  const [isInView, setIsInView] = useState(false);\n  const [hasError, setHasError] = useState(false);\n  const [videoSources, setVideoSources] = useState([]);\n  const [preloadedVideo, setPreloadedVideo] = useState(null);\n  const videoRef = useRef(null);\n  const observerRef = useRef(null);\n\n  // Initialize video sources and check for preloaded videos\n  useEffect(() => {\n    if (videoId) {\n      // Check if video is already preloaded\n      const preloaded = intelligentVideoPreloader.getPreloadedVideo(videoId);\n      if (preloaded) {\n        setPreloadedVideo(preloaded);\n        setVideoSources([preloaded.source]);\n      } else {\n        // Generate adaptive sources\n        const optimalSource = intelligentVideoPreloader.getOptimalVideoSource(videoId, priority);\n        setVideoSources([optimalSource]);\n        \n        // Preload for future use if priority is high\n        if (priority === 'high') {\n          intelligentVideoPreloader.preloadVideo(videoId, priority);\n        }\n      }\n    } else if (src) {\n      // Fallback to traditional src prop\n      setVideoSources([{ src, format: 'mp4', quality: 'unknown' }]);\n    }\n  }, [videoId, src, priority]);\n\n  // Intersection Observer for lazy loading and viewport management\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const isCurrentlyInView = entry.isIntersecting;\n        setIsInView(isCurrentlyInView);\n        \n        // Track user interaction for intelligent preloading\n        if (videoId && isCurrentlyInView) {\n          intelligentVideoPreloader.trackUserInteraction('video_view', videoId, {\n            viewportPercentage: entry.intersectionRatio\n          });\n        }\n        \n        // For lazy loading\n        if (lazy && isCurrentlyInView && !isVisible) {\n          setIsVisible(true);\n        }\n        \n        // Enhanced video playback management based on viewport\n        if (videoRef.current && isLoaded) {\n          const isMobile = window.innerWidth <= 768;\n          \n          if (isCurrentlyInView) {\n            // Video is in view, play it\n            if (autoPlay && videoRef.current.paused) {\n              // Enhanced delay calculation based on device and network\n              const networkInfo = intelligentVideoPreloader.networkInfo;\n              const isSlowNetwork = networkInfo.effectiveType === '3g' || networkInfo.downlink < 3;\n              const delay = isMobile ? (isSlowNetwork ? 200 : 150) : 50;\n              \n              setTimeout(() => {\n                if (videoRef.current) {\n                  const playPromise = videoRef.current.play();\n                  if (playPromise !== undefined) {\n                    playPromise.catch(error => {\n                      // Auto-play was prevented, but that's okay\n                    });\n                  }\n                }\n              }, delay);\n            }\n          } else {\n            // Video is out of view, pause it for better performance\n            if (!videoRef.current.paused) {\n              videoRef.current.pause();\n            }\n            \n            // Enhanced memory optimization for mobile\n            if (isMobile) {\n              const deviceInfo = intelligentVideoPreloader.deviceInfo;\n              const resetThreshold = deviceInfo.isLowPower ? 3 : 5;\n              \n              if (videoRef.current.currentTime > resetThreshold) {\n                videoRef.current.currentTime = 0;\n              }\n              \n              // More aggressive cleanup on low-power devices\n              if (deviceInfo.isLowPower) {\n                try {\n                  videoRef.current.load();\n                } catch (e) {\n                  // Ignore errors\n                }\n              }\n            }\n          }\n        }\n      },\n      { \n        threshold: window.innerWidth <= 768 ? [0.25] : [0, 0.1, 0.5],\n        rootMargin: window.innerWidth <= 768 ? '75px 0px' : '50px 0px'\n      }\n    );\n\n    observerRef.current = observer;\n\n    if (videoRef.current) {\n      observer.observe(videoRef.current);\n    }\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, [lazy, isLoaded, autoPlay, videoId]);\n\n  // Auto-play when video becomes visible and loaded\n  useEffect(() => {\n    if (isLoaded && videoRef.current && autoPlay && isInView) {\n      const playPromise = videoRef.current.play();\n      if (playPromise !== undefined) {\n        playPromise.catch(error => {\n          // Auto-play was prevented, but that's okay\n        });\n      }\n    }\n  }, [isLoaded, autoPlay, isInView]);\n\n  const handleVideoLoad = () => {\n    setIsLoaded(true);\n    \n    // Track successful video load\n    if (videoId) {\n      intelligentVideoPreloader.trackUserInteraction('video_loaded', videoId, {\n        loadTime: Date.now()\n      });\n    }\n  };\n\n  const handleVideoError = (e) => {\n    console.warn('Video failed to load:', e.target?.src);\n    setHasError(true);\n    \n    // Track video error for analytics\n    if (videoId) {\n      intelligentVideoPreloader.trackUserInteraction('video_error', videoId, {\n        error: e.target?.error?.message || 'Unknown error',\n        src: e.target?.src\n      });\n    }\n  };\n\n  // If there's an error, render the fallback image (no play button)\n  if (hasError) {\n    return (\n      <div ref={videoRef} className={`optimized-video-container ${className}`} style={style}>\n        <img\n          src={fallbackImage || poster}\n          alt={alt}\n          className=\"video-fallback-image\"\n          loading=\"lazy\"\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div ref={videoRef} className={`optimized-video-container ${className}`} style={style}>\n      {/* Poster image - no loading spinner */}\n      {!isLoaded && poster && (\n        <div className=\"video-poster\">\n          <img\n            src={poster}\n            alt={alt}\n            className=\"poster-image\"\n            loading=\"lazy\"\n          />\n        </div>\n      )}\n\n      {/* Video element with adaptive sources */}\n      {isVisible && (\n        <video\n          ref={videoRef}\n          poster={poster}\n          className={`optimized-video ${isLoaded ? 'loaded' : 'loading'}`}\n          autoPlay={false} // Controlled by intersection observer\n          muted={muted}\n          loop={loop}\n          playsInline={playsInline}\n          preload={preloadedVideo ? \"auto\" : \"metadata\"}\n          onCanPlay={handleVideoLoad}\n          onError={handleVideoError}\n          style={style}\n        >\n          {/* Multiple sources for progressive enhancement */}\n          {videoSources.map((source, index) => (\n            <source\n              key={index}\n              src={source.src}\n              type={source.type || `video/${source.format}`}\n              onError={index === videoSources.length - 1 ? handleVideoError : undefined}\n            />\n          ))}\n          \n          {/* Fallback content for browsers that don't support video */}\n          <img\n            src={fallbackImage || poster}\n            alt={alt}\n            className=\"video-fallback\"\n          />\n        </video>\n      )}\n    </div>\n  );\n};\n\nexport default OptimizedVideo; "],"names":["constructor","this","preloadedVideos","Map","preloadQueue","isPreloading","networkInfo","getNetworkInfo","deviceInfo","getDeviceInfo","userBehavior","getUserBehavior","setupNetworkMonitoring","preloadCriticalVideos","connection","navigator","mozConnection","webkitConnection","effectiveType","downlink","rtt","saveData","width","window","innerWidth","memory","deviceMemory","hardwareConcurrency","isMobile","isTablet","isDesktop","isLowPower","pixelRatio","devicePixelRatio","stored","localStorage","getItem","defaults","averageViewTime","scrollSpeed","interactionPatterns","preferredQuality","batteryOptimization","_objectSpread","JSON","parse","addEventListener","adjustPreloadingStrategy","getBattery","then","battery","updateBatteryInfo","level","charging","slice","getOptimalVideoSource","videoId","priority","arguments","length","undefined","quality","video","document","createElement","format","canPlayType","src","concat","poster","preloadVideo","has","get","shouldPreload","videoSource","preload","muted","playsInline","preloadPromise","Promise","resolve","reject","timeoutId","setTimeout","Error","clearTimeout","source","preloadedAt","Date","now","once","event","errorMsg","target","error","message","result","set","cleanupOldPreloads","console","warn","maxPreloads","preloads","Array","from","entries","forEach","_ref","data","delete","load","size","sort","a","b","_ref2","preloadPromises","map","async","allSettled","preloadOnScroll","visibleVideoIds","upcomingVideoIds","promises","getPreloadedVideo","trackUserInteraction","eventType","interaction","timestamp","push","setItem","stringify","getPerformanceMetrics","preloadedCount","networkType","deviceType","memoryUsage","fallbackImage","alt","className","style","autoPlay","loop","lazy","isLoaded","setIsLoaded","useState","isVisible","setIsVisible","isInView","setIsInView","hasError","setHasError","videoSources","setVideoSources","preloadedVideo","setPreloadedVideo","videoRef","useRef","observerRef","useEffect","preloaded","intelligentVideoPreloader","optimalSource","observer","IntersectionObserver","entry","isCurrentlyInView","isIntersecting","viewportPercentage","intersectionRatio","current","paused","isSlowNetwork","playPromise","play","catch","pause","resetThreshold","currentTime","e","threshold","rootMargin","observe","disconnect","handleVideoError","_e$target","_e$target2","_e$target2$error","_e$target3","_jsx","ref","children","loading","_jsxs","onCanPlay","handleVideoLoad","loadTime","onError","index","type"],"sourceRoot":""}