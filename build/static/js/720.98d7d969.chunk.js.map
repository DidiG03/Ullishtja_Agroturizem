{"version":3,"file":"static/js/720.98d7d969.chunk.js","mappings":"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","sources":["components/OptimizedVideo.js","services/intelligentVideoPreloader.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport intelligentVideoPreloader from '../services/intelligentVideoPreloader';\nimport './OptimizedVideo.css';\n\nconst OptimizedVideo = ({ \n  src, \n  videoId, // New prop for intelligent loading\n  poster, \n  fallbackImage, \n  alt = \"Video\", \n  className = \"\", \n  style = {},\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  playsInline = true,\n  lazy = true,\n  priority = 'normal' // New prop for preloading priority\n}) => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [isVisible, setIsVisible] = useState(!lazy);\n  const [isInView, setIsInView] = useState(false);\n  const [hasError, setHasError] = useState(false);\n  const [videoSources, setVideoSources] = useState([]);\n  const [preloadedVideo, setPreloadedVideo] = useState(null);\n  const videoRef = useRef(null);\n  const observerRef = useRef(null);\n\n  // Initialize video sources and check for preloaded videos\n  useEffect(() => {\n    if (videoId) {\n      // Check if video is already preloaded\n      const preloaded = intelligentVideoPreloader.getPreloadedVideo(videoId);\n      if (preloaded) {\n        setPreloadedVideo(preloaded);\n        setVideoSources([preloaded.source]);\n      } else {\n        // Generate adaptive sources\n        const optimalSource = intelligentVideoPreloader.getOptimalVideoSource(videoId, priority);\n        setVideoSources([optimalSource]);\n        \n        // Preload for future use if priority is high\n        if (priority === 'high') {\n          intelligentVideoPreloader.preloadVideo(videoId, priority);\n        }\n      }\n    } else if (src) {\n      // Fallback to traditional src prop\n      setVideoSources([{ src, format: 'mp4', quality: 'unknown' }]);\n    }\n  }, [videoId, src, priority]);\n\n  // Intersection Observer for lazy loading and viewport management\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const isCurrentlyInView = entry.isIntersecting;\n        setIsInView(isCurrentlyInView);\n        \n        // Track user interaction for intelligent preloading\n        if (videoId && isCurrentlyInView) {\n          intelligentVideoPreloader.trackUserInteraction('video_view', videoId, {\n            viewportPercentage: entry.intersectionRatio\n          });\n        }\n        \n        // For lazy loading\n        if (lazy && isCurrentlyInView && !isVisible) {\n          setIsVisible(true);\n        }\n        \n        // Enhanced video playback management based on viewport\n        if (videoRef.current && isLoaded) {\n          const isMobile = window.innerWidth <= 768;\n          \n          if (isCurrentlyInView) {\n            // Video is in view, play it\n            if (autoPlay && videoRef.current.paused) {\n              // Enhanced delay calculation based on device and network\n              const networkInfo = intelligentVideoPreloader.networkInfo;\n              const isSlowNetwork = networkInfo.effectiveType === '3g' || networkInfo.downlink < 3;\n              const delay = isMobile ? (isSlowNetwork ? 200 : 150) : 50;\n              \n              setTimeout(() => {\n                if (videoRef.current) {\n                  const playPromise = videoRef.current.play();\n                  if (playPromise !== undefined) {\n                    playPromise.catch(error => {\n                      console.log('Auto-play prevented:', error);\n                    });\n                  }\n                }\n              }, delay);\n            }\n          } else {\n            // Video is out of view, pause it for better performance\n            if (!videoRef.current.paused) {\n              videoRef.current.pause();\n            }\n            \n            // Enhanced memory optimization for mobile\n            if (isMobile) {\n              const deviceInfo = intelligentVideoPreloader.deviceInfo;\n              const resetThreshold = deviceInfo.isLowPower ? 3 : 5;\n              \n              if (videoRef.current.currentTime > resetThreshold) {\n                videoRef.current.currentTime = 0;\n              }\n              \n              // More aggressive cleanup on low-power devices\n              if (deviceInfo.isLowPower) {\n                try {\n                  videoRef.current.load();\n                } catch (e) {\n                  // Ignore errors\n                }\n              }\n            }\n          }\n        }\n      },\n      { \n        threshold: window.innerWidth <= 768 ? [0.25] : [0, 0.1, 0.5],\n        rootMargin: window.innerWidth <= 768 ? '75px 0px' : '50px 0px'\n      }\n    );\n\n    observerRef.current = observer;\n\n    if (videoRef.current) {\n      observer.observe(videoRef.current);\n    }\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, [lazy, isLoaded, autoPlay, videoId]);\n\n  // Auto-play when video becomes visible and loaded\n  useEffect(() => {\n    if (isLoaded && videoRef.current && autoPlay && isInView) {\n      const playPromise = videoRef.current.play();\n      if (playPromise !== undefined) {\n        playPromise.catch(error => {\n          // Auto-play was prevented, but that's okay\n          console.log('Auto-play prevented:', error);\n        });\n      }\n    }\n  }, [isLoaded, autoPlay, isInView]);\n\n  const handleVideoLoad = () => {\n    setIsLoaded(true);\n    \n    // Track successful video load\n    if (videoId) {\n      intelligentVideoPreloader.trackUserInteraction('video_loaded', videoId, {\n        loadTime: Date.now()\n      });\n    }\n  };\n\n  const handleVideoError = (e) => {\n    console.warn('Video failed to load:', e.target?.src);\n    setHasError(true);\n    \n    // Track video error for analytics\n    if (videoId) {\n      intelligentVideoPreloader.trackUserInteraction('video_error', videoId, {\n        error: e.target?.error?.message || 'Unknown error',\n        src: e.target?.src\n      });\n    }\n  };\n\n  // If there's an error, render the fallback image (no play button)\n  if (hasError) {\n    return (\n      <div ref={videoRef} className={`optimized-video-container ${className}`} style={style}>\n        <img\n          src={fallbackImage || poster}\n          alt={alt}\n          className=\"video-fallback-image\"\n          loading=\"lazy\"\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div ref={videoRef} className={`optimized-video-container ${className}`} style={style}>\n      {/* Poster image - no loading spinner */}\n      {!isLoaded && poster && (\n        <div className=\"video-poster\">\n          <img\n            src={poster}\n            alt={alt}\n            className=\"poster-image\"\n            loading=\"lazy\"\n          />\n        </div>\n      )}\n\n      {/* Video element with adaptive sources */}\n      {isVisible && (\n        <video\n          ref={videoRef}\n          poster={poster}\n          className={`optimized-video ${isLoaded ? 'loaded' : 'loading'}`}\n          autoPlay={false} // Controlled by intersection observer\n          muted={muted}\n          loop={loop}\n          playsInline={playsInline}\n          preload={preloadedVideo ? \"auto\" : \"metadata\"}\n          onCanPlay={handleVideoLoad}\n          onError={handleVideoError}\n          style={style}\n        >\n          {/* Multiple sources for progressive enhancement */}\n          {videoSources.map((source, index) => (\n            <source\n              key={index}\n              src={source.src}\n              type={source.type || `video/${source.format}`}\n              onError={index === videoSources.length - 1 ? handleVideoError : undefined}\n            />\n          ))}\n          \n          {/* Fallback content for browsers that don't support video */}\n          <img\n            src={fallbackImage || poster}\n            alt={alt}\n            className=\"video-fallback\"\n          />\n        </video>\n      )}\n    </div>\n  );\n};\n\nexport default OptimizedVideo; ","class IntelligentVideoPreloader {\n  constructor() {\n    this.preloadedVideos = new Map();\n    this.preloadQueue = [];\n    this.isPreloading = false;\n    this.networkInfo = this.getNetworkInfo();\n    this.deviceInfo = this.getDeviceInfo();\n    this.userBehavior = this.getUserBehavior();\n    \n    // Monitor network changes\n    this.setupNetworkMonitoring();\n    \n    // Preload critical videos on initialization\n    this.preloadCriticalVideos();\n  }\n\n  getNetworkInfo() {\n    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n    \n    if (!connection) {\n      return {\n        effectiveType: '4g',\n        downlink: 10,\n        rtt: 100,\n        saveData: false\n      };\n    }\n\n    return {\n      effectiveType: connection.effectiveType || '4g',\n      downlink: connection.downlink || 10,\n      rtt: connection.rtt || 100,\n      saveData: connection.saveData || false\n    };\n  }\n\n  getDeviceInfo() {\n    const width = window.innerWidth;\n    const memory = navigator.deviceMemory || 4;\n    const hardwareConcurrency = navigator.hardwareConcurrency || 4;\n    \n    return {\n      isMobile: width <= 768,\n      isTablet: width > 768 && width <= 1024,\n      isDesktop: width > 1024,\n      memory,\n      hardwareConcurrency,\n      isLowPower: hardwareConcurrency <= 2 || memory <= 2,\n      pixelRatio: window.devicePixelRatio || 1\n    };\n  }\n\n  getUserBehavior() {\n    // Get user behavior patterns from localStorage or set defaults\n    const stored = localStorage.getItem('video_user_behavior');\n    const defaults = {\n      averageViewTime: 30000, // 30 seconds\n      scrollSpeed: 'medium',\n      interactionPatterns: [],\n      preferredQuality: 'auto',\n      batteryOptimization: false\n    };\n\n    return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;\n  }\n\n  setupNetworkMonitoring() {\n    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n    \n    if (connection) {\n      connection.addEventListener('change', () => {\n        this.networkInfo = this.getNetworkInfo();\n        this.adjustPreloadingStrategy();\n      });\n    }\n\n    // Monitor battery status\n    if ('getBattery' in navigator) {\n      navigator.getBattery().then(battery => {\n        const updateBatteryInfo = () => {\n          this.userBehavior.batteryOptimization = battery.level < 0.2 || !battery.charging;\n        };\n        \n        battery.addEventListener('levelchange', updateBatteryInfo);\n        battery.addEventListener('chargingchange', updateBatteryInfo);\n        updateBatteryInfo();\n      });\n    }\n  }\n\n  adjustPreloadingStrategy() {\n    const { effectiveType, saveData, downlink } = this.networkInfo;\n    const { isLowPower } = this.deviceInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Clear preload queue if conditions are poor\n    if (saveData || batteryOptimization || effectiveType === 'slow-2g' || effectiveType === '2g') {\n      this.preloadQueue = [];\n      return;\n    }\n\n    // Adjust preloading aggressiveness based on network quality\n    if (effectiveType === '3g' || downlink < 5 || isLowPower) {\n      // Conservative preloading\n      this.preloadQueue = this.preloadQueue.slice(0, 2);\n    }\n  }\n\n  getOptimalVideoSource(videoId, priority = 'normal') {\n    const { isMobile, isTablet, isDesktop, isLowPower } = this.deviceInfo;\n    const { effectiveType, downlink, saveData } = this.networkInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Determine optimal quality\n    let quality = 'mobile';\n    if (isTablet && !isLowPower && !saveData) quality = 'tablet';\n    if (isDesktop && !batteryOptimization && downlink > 5) quality = 'desktop';\n\n    // Downgrade for poor network conditions\n    if (effectiveType === 'slow-2g' || effectiveType === '2g') {\n      quality = 'mobile';\n    } else if (effectiveType === '3g' && quality === 'desktop') {\n      quality = 'tablet';\n    }\n\n    // Determine optimal format\n    const video = document.createElement('video');\n    const supportsWebM = video.canPlayType('video/webm') !== '';\n    const supportsAV1 = video.canPlayType('video/webm; codecs=\"av01.0.05M.08\"') !== '';\n\n    let format = 'mp4';\n    if (supportsWebM && downlink > 2) format = 'webm';\n    if (supportsAV1 && downlink > 5 && !isLowPower && priority === 'high') format = 'av1';\n\n    return {\n      src: `/videos/${videoId}-${quality}.${format === 'av1' ? 'av1.mp4' : format}`,\n      quality,\n      format,\n      poster: `/videos/${videoId}-poster.jpg`\n    };\n  }\n\n  async preloadVideo(videoId, priority = 'normal') {\n    // Check if already preloaded\n    if (this.preloadedVideos.has(videoId)) {\n      return this.preloadedVideos.get(videoId);\n    }\n\n    // Check if we should preload based on current conditions\n    if (!this.shouldPreload(priority)) {\n      return null;\n    }\n\n    const videoSource = this.getOptimalVideoSource(videoId, priority);\n    \n    try {\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n      video.muted = true;\n      video.playsInline = true;\n\n      // Create a promise that resolves when video is ready\n      const preloadPromise = new Promise((resolve, reject) => {\n        const timeoutId = setTimeout(() => {\n          reject(new Error('Preload timeout'));\n        }, 10000); // 10 second timeout\n\n        video.addEventListener('loadedmetadata', () => {\n          clearTimeout(timeoutId);\n          resolve({\n            video,\n            source: videoSource,\n            preloadedAt: Date.now()\n          });\n        }, { once: true });\n\n        video.addEventListener('error', () => {\n          clearTimeout(timeoutId);\n          reject(new Error('Video preload failed'));\n        }, { once: true });\n      });\n\n      video.src = videoSource.src;\n      \n      const result = await preloadPromise;\n      this.preloadedVideos.set(videoId, result);\n      \n      // Clean up old preloaded videos if memory is getting full\n      this.cleanupOldPreloads();\n      \n      return result;\n    } catch (error) {\n      console.warn(`Failed to preload video ${videoId}:`, error);\n      return null;\n    }\n  }\n\n  shouldPreload(priority) {\n    const { effectiveType, saveData, downlink } = this.networkInfo;\n    const { isLowPower } = this.deviceInfo;\n    const { batteryOptimization } = this.userBehavior;\n\n    // Never preload on data saver mode or very poor connections\n    if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g') {\n      return false;\n    }\n\n    // Don't preload on low battery\n    if (batteryOptimization) {\n      return priority === 'high';\n    }\n\n    // Conservative preloading on low-power devices\n    if (isLowPower) {\n      return priority === 'high' && downlink > 2;\n    }\n\n    // Liberal preloading on good connections\n    if (effectiveType === '4g' && downlink > 5) {\n      return true;\n    }\n\n    // Medium preloading on decent connections\n    if (effectiveType === '3g' || downlink > 2) {\n      return priority !== 'low';\n    }\n\n    return false;\n  }\n\n  cleanupOldPreloads() {\n    const maxPreloads = this.deviceInfo.isLowPower ? 3 : 6;\n    const now = Date.now();\n    const maxAge = 5 * 60 * 1000; // 5 minutes\n\n    // Convert to array for sorting\n    const preloads = Array.from(this.preloadedVideos.entries());\n    \n    // Remove old preloads\n    preloads.forEach(([videoId, data]) => {\n      if (now - data.preloadedAt > maxAge) {\n        this.preloadedVideos.delete(videoId);\n        if (data.video) {\n          data.video.src = '';\n          data.video.load();\n        }\n      }\n    });\n\n    // If still too many, remove oldest\n    if (this.preloadedVideos.size > maxPreloads) {\n      const sortedPreloads = preloads\n        .sort((a, b) => a[1].preloadedAt - b[1].preloadedAt)\n        .slice(0, this.preloadedVideos.size - maxPreloads);\n\n      sortedPreloads.forEach(([videoId, data]) => {\n        this.preloadedVideos.delete(videoId);\n        if (data.video) {\n          data.video.src = '';\n          data.video.load();\n        }\n      });\n    }\n  }\n\n  async preloadCriticalVideos() {\n    // Define critical videos that should be preloaded immediately\n    const criticalVideos = [\n      'dji-20240806130059-0020-d', // Hero video\n      'dji-20240806130609-0022-d'  // Most viewed video\n    ];\n\n    // Only preload if conditions are good\n    if (!this.shouldPreload('normal')) {\n      return;\n    }\n\n    // Preload critical videos with high priority\n    const preloadPromises = criticalVideos.map(videoId => \n      this.preloadVideo(videoId, 'high')\n    );\n\n    try {\n      await Promise.allSettled(preloadPromises);\n    } catch (error) {\n      console.warn('Some critical videos failed to preload:', error);\n    }\n  }\n\n  // Method to intelligently preload based on scroll position and user behavior\n  async preloadOnScroll(visibleVideoIds, upcomingVideoIds) {\n    if (!this.shouldPreload('normal')) {\n      return;\n    }\n\n    // Preload upcoming videos based on scroll direction and speed\n    const promises = upcomingVideoIds.slice(0, 2).map(videoId => \n      this.preloadVideo(videoId, 'normal')\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  // Get preloaded video if available\n  getPreloadedVideo(videoId) {\n    return this.preloadedVideos.get(videoId);\n  }\n\n  // Track user interaction patterns for better prediction\n  trackUserInteraction(eventType, videoId, data = {}) {\n    const interaction = {\n      timestamp: Date.now(),\n      eventType,\n      videoId,\n      ...data\n    };\n\n    this.userBehavior.interactionPatterns.push(interaction);\n\n    // Keep only recent interactions (last 100)\n    if (this.userBehavior.interactionPatterns.length > 100) {\n      this.userBehavior.interactionPatterns = this.userBehavior.interactionPatterns.slice(-100);\n    }\n\n    // Save to localStorage\n    localStorage.setItem('video_user_behavior', JSON.stringify(this.userBehavior));\n  }\n\n  // Get performance metrics\n  getPerformanceMetrics() {\n    return {\n      preloadedCount: this.preloadedVideos.size,\n      networkType: this.networkInfo.effectiveType,\n      deviceType: this.deviceInfo.isMobile ? 'mobile' : this.deviceInfo.isTablet ? 'tablet' : 'desktop',\n      batteryOptimization: this.userBehavior.batteryOptimization,\n      memoryUsage: this.preloadedVideos.size * 0.5 // Estimated MB per preloaded video\n    };\n  }\n}\n\n// Create singleton instance\nconst intelligentVideoPreloader = new IntelligentVideoPreloader();\n\nexport default intelligentVideoPreloader; "],"names":["_ref","src","videoId","poster","fallbackImage","alt","className","style","autoPlay","muted","loop","playsInline","lazy","priority","isLoaded","setIsLoaded","useState","isVisible","setIsVisible","isInView","setIsInView","hasError","setHasError","videoSources","setVideoSources","preloadedVideo","setPreloadedVideo","videoRef","useRef","observerRef","useEffect","preloaded","intelligentVideoPreloader","getPreloadedVideo","source","optimalSource","getOptimalVideoSource","preloadVideo","format","quality","observer","IntersectionObserver","_ref2","entry","isCurrentlyInView","isIntersecting","trackUserInteraction","viewportPercentage","intersectionRatio","current","isMobile","window","innerWidth","paused","networkInfo","isSlowNetwork","effectiveType","downlink","setTimeout","playPromise","play","undefined","catch","error","console","log","pause","deviceInfo","resetThreshold","isLowPower","currentTime","load","e","threshold","rootMargin","observe","disconnect","handleVideoError","_e$target","_e$target2","_e$target2$error","_e$target3","warn","target","message","_jsx","ref","concat","children","loading","_jsxs","preload","onCanPlay","handleVideoLoad","loadTime","Date","now","onError","map","index","type","length","constructor","this","preloadedVideos","Map","preloadQueue","isPreloading","getNetworkInfo","getDeviceInfo","userBehavior","getUserBehavior","setupNetworkMonitoring","preloadCriticalVideos","connection","navigator","mozConnection","webkitConnection","rtt","saveData","width","memory","deviceMemory","hardwareConcurrency","isTablet","isDesktop","pixelRatio","devicePixelRatio","stored","localStorage","getItem","defaults","averageViewTime","scrollSpeed","interactionPatterns","preferredQuality","batteryOptimization","_objectSpread","JSON","parse","addEventListener","adjustPreloadingStrategy","getBattery","then","battery","updateBatteryInfo","level","charging","slice","arguments","video","document","createElement","canPlayType","has","get","shouldPreload","videoSource","preloadPromise","Promise","resolve","reject","timeoutId","Error","clearTimeout","preloadedAt","once","result","set","cleanupOldPreloads","maxPreloads","preloads","Array","from","entries","forEach","data","delete","size","sort","a","b","preloadPromises","allSettled","preloadOnScroll","visibleVideoIds","upcomingVideoIds","promises","eventType","interaction","timestamp","push","setItem","stringify","getPerformanceMetrics","preloadedCount","networkType","deviceType","memoryUsage"],"sourceRoot":""}